# Generated by Ansible at {{ ansible_date_time.iso8601 }}

vcl 4.0;
# Based on: https://github.com/mattiasgeniar/varnish-4.0-configuration-templates/blob/master/default.vcl

import std;
import directors;

backend frontendWebsite {
  .host = "127.0.0.1";
  .port = "{{ nginx_server_port }}";
  .host_header = "{{ nginx_server_name }}";
  .max_connections = 768;

  .probe = {
    .url = "/";

    .interval = 5s;
    .timeout = 1s;
    .window = 5;
    .threshold = 5;
  }
}

# Should possibly consider adding a backend health check page (vs. /version) that ensures things are okay with Redis?
{% for backend in varnish_backends %}
backend {{ backend.name }} {
  .host = "{{ backend.address }}";
  .port = "{{ backend.port }}";

  .connect_timeout = 4s;
  .first_byte_timeout = 10s;
  .between_bytes_timeout = 2s;

  .probe = {
    #.url = "/check";
    .url = "/version";
    .interval = 5s;
    .timeout = 2s;
    .window = 5;
    .threshold = 3;
  }
}
{% endfor %}

acl purge {
  # ACL we'll use later to allow purges
  "localhost";
  "127.0.0.1";
  "::1";
}

sub vcl_init {
  # Called when VCL is loaded, before any requests pass through it.
  # Typically used to initialize VMODs.

  new vdir = directors.round_robin();
  {% for backend in varnish_backends %}
  vdir.add_backend({{ backend.name }});
  {% endfor %}
}

sub vcl_recv {
  # Called at the beginning of a request, after the complete request has been received and parsed.
  # Its purpose is to decide whether or not to serve the request, how to do it, and, if applicable,
  # which backend to use.
  # also used to modify the request

  set req.backend_hint = vdir.backend(); # send all traffic to the vdir director

  # If not for the server_name && not the server_name redirect then we can drop it.
  if (req.http.host != "{{ nginx_server_name }}" && req.http.host != "{{ nginx_server_nameredirect }}") {
    return (synth(403, "Forbidden"));
  }

  # Let's remove all query strings, ampersands and hashes
  # These should not appear in any requests and are unrequired.
  if (req.url ~ "\?|&|#") {
    # pretty sure there should be a |# here...
    set req.url = regsub(req.url, "(\?|&|\#).*$", "");
  }

  # Redirect www to no-www and keep the URI
  if (req.http.host == "{{ nginx_server_nameredirect }}") {
    # Handle HTTP/S by looking for the X-Forwarded-Proto header.
    if (req.http.x-forwarded-proto == "https") {
        return (synth(720, "https://{{ nginx_server_name }}" + req.url));
    } else {
        return (synth(720, "http://{{ nginx_server_name }}" + req.url));
    }
  }

  # Remove all cookies
  unset req.http.cookie;

  # Allow purging
  if (req.method == "PURGE") {
    if (!client.ip ~ purge) { # purge is the ACL defined at the begining
      # Not from an allowed IP? Then die with an error.
      return (synth(405, "This IP is not allowed to send PURGE requests."));
    }
    # If you got this stage (and didn't error out above), purge the cached result
    return (purge);
  }

  # Only deal with GET and HEAD, setting it to GET if we get something funny
  if (req.method != "GET" &&
      req.method != "HEAD") {
    set req.method = "GET";
  }

  # We want to make each stats page available under a special name and set lower TTLs
  if (req.url ~ "^/stats/") {
    call backend_stats;
  }

  # Well this is digusting...
  if (req.url == "/" || req.url == "/favicon.ico" || req.url == "/robots.txt" || req.url == "/404.html" || req.url ~ "^/assets/" || req.url ~ "^/addons/") {
    set req.backend_hint = frontendWebsite;
  }

  return (hash);
}

sub vcl_pipe {
  # Called upon entering pipe mode.
  # In this mode, the request is passed on to the backend, and any further data from both the client
  # and backend is passed on unaltered until either end closes the connection. Basically, Varnish will
  # degrade into a simple TCP proxy, shuffling bytes back and forth. For a connection in pipe mode,
  # no other VCL subroutine will ever get called after vcl_pipe.

  # Note that only the first request to the backend will have
  # X-Forwarded-For set.  If you use X-Forwarded-For and want to
  # have it set for all requests, make sure to have:
  # set bereq.http.connection = "close";
  # here.  It is not set by default as it might break some broken web
  # applications, like IIS with NTLM authentication.

  # set bereq.http.Connection = "Close";

  return (pipe);
}

sub vcl_pass {
  # Called upon entering pass mode. In this mode, the request is passed on to the backend, and the
  # backend's response is passed on to the client, but is not entered into the cache. Subsequent
  # requests submitted over the same client connection are handled normally.

  # return (pass);
}

# The data on which the hashing will take place
sub vcl_hash {
  # Called after vcl_recv to create a hash value for the request. This is used as a key
  # to look up the object in Varnish.

    hash_data(req.url);
    if (req.http.host) {
        # Should always hash with just the main site as we redirect/error on everything else.
        hash_data(req.http.host);
    } else {
        # Should not be used
        hash_data(server.ip);
    }
    return (lookup);
}

sub vcl_hit {
  # Called when a cache lookup is successful.

  if (obj.ttl >= 0s) {
    # A pure unadultered hit, deliver it
    return (deliver);
  }

  # https://www.varnish-cache.org/docs/trunk/users-guide/vcl-grace.html
  # When several clients are requesting the same page Varnish will send one request to the backend and place the others on hold while fetching one copy from the backend. In some products this is called request coalescing and Varnish does this automatically.
  # If you are serving thousands of hits per second the queue of waiting requests can get huge. There are two potential problems - one is a thundering herd problem - suddenly releasing a thousand threads to serve content might send the load sky high. Secondly - nobody likes to wait. To deal with this we can instruct Varnish to keep the objects in cache beyond their TTL and to serve the waiting requests somewhat stale content.

# if (!std.healthy(req.backend_hint) && (obj.ttl + obj.grace > 0s)) {
#   return (deliver);
# } else {
#   return (fetch);
# }

  call object_grace;

  # fetch & deliver once we get the result
  return (fetch); # Dead code, keep as a safeguard
}

sub vcl_miss {
  # Called after a cache lookup if the requested document was not found in the cache. Its purpose
  # is to decide whether or not to attempt to retrieve the document from the backend, and which
  # backend to use.

  return (fetch);
}

# Handle the HTTP request coming from our backend
sub vcl_backend_response {
  # Called after the response headers has been successfully retrieved from the backend.

  # Remove all cookies, cache everything
  unset beresp.http.Set-Cookie;

{% if varnish_extra_headers %}
  # Return backend name with each request
  set beresp.http.X-Backend = beresp.backend.name;
{% endif %}

  # We may as well introduce some basic caching of the stats
  if (bereq.url ~ "^/stats") {
    set beresp.ttl = 5s;
    # Disable grace
    set beresp.grace = 0s;
    return (deliver);
  }

  # Set 2min cache if unset for static files
  if (beresp.ttl <= 0s || beresp.http.Vary == "*") {
    set beresp.ttl = 120s; # Important, you shouldn't rely on this, SET YOUR HEADERS in the backend
    # The uncacheable header tells Varnish to keep a record that we should not cache this request and we should go to backend.
    #set beresp.uncacheable = true;
    return (deliver);
  }

  # Allow stale content, in case the backend goes down.
  # make Varnish keep all objects for 6 hours beyond their TTL
  set beresp.grace = 6h;

  return (deliver);
}

# The routine when we deliver the HTTP request to the user
# Last chance to modify headers that are sent to the client
sub vcl_deliver {
  # Called before a cached object is delivered to the client.

{% if varnish_extra_headers %}
  if (obj.hits > 0) { # Add debug header to see if it's a HIT/MISS and the number of hits, disable when not needed
    set resp.http.X-Cache = "HIT";
  } else {
    set resp.http.X-Cache = "MISS";
  }

  if (req.http.grace) {
    set resp.http.X-Grace = req.http.grace;
  }

  # Please note that obj.hits behaviour changed in 4.0, now it counts per objecthead, not per object
  # and obj.hits may not be reset in some cases where bans are in use. See bug 1492 for details.
  # So take hits with a grain of salt
  set resp.http.X-Cache-Hits = obj.hits;
{% endif %}

  call header_cleanup;
}

sub vcl_purge {
  # Only handle actual PURGE HTTP methods, everything else is discarded
  if (req.method != "PURGE") {
    # restart request
    set req.http.X-Purge = "Yes";
    return(restart);
  }
}

sub vcl_synth {
  if (resp.status == 720) {
    # We use this special error status 720 to force redirects with 301 (permanent) redirects
    # To use this, call the following from anywhere in vcl_recv: return (synth(720, "http://host/new.html"));
    set resp.http.Location = resp.reason;
    set resp.status = 301;
  } elseif (resp.status == 721) {
    # And we use error status 721 to force redirects with a 302 (temporary) redirect
    # To use this, call the following from anywhere in vcl_recv: return (synth(720, "http://host/new.html"));
    set resp.http.Location = resp.reason;
    set resp.status = 302;
  }

  call header_cleanup;
}

# Called when the object is cached but past the ttl.
sub object_grace {
  if (std.healthy(req.backend_hint)) {
    # Backend is healthy. Limit age to 10s.
    if (obj.ttl + 10s > 0s) {
{% if varnish_extra_headers %}
      set req.http.grace = "SHORT";
{% endif %}
      return (deliver);
    } else {
      # No candidate for grace. Fetch a fresh object.
      return(fetch);
    }
  } else {
    # backend is sick - use full grace
      if (obj.ttl + obj.grace > 0s) {
{% if varnish_extra_headers %}
      set req.http.grace = "FULL";
{% endif %}
      return (deliver);
    } else {
      # no graced object.
      return (fetch);
    }
  }
}

# Setting custom req.url so the cache works
sub backend_stats {
    if (req.url == "/stats/nginx") {
      set req.backend_hint = frontendWebsite;
      set req.url = "/stats?nginx";
    }
    {% for backend in varnish_backends %}
    if (req.url == "/stats/{{ backend.name }}") {
      set req.backend_hint = {{ backend.name }};
      set req.url = "/stats?{{ backend.name }}";
    }
    {% endfor %}

  return (hash);
}

# Header cleanup and removal for headers which we don't want making it to the clients.
sub header_cleanup {
  unset resp.http.X-Powered-By;
  unset resp.http.Server;
  unset resp.http.X-Drupal-Cache;
  unset resp.http.X-Varnish;
  unset resp.http.Via;
  unset resp.http.Link;
  unset resp.http.X-Generator;

  return (deliver);
}

sub vcl_fini {
  # Called when VCL is discarded only after all requests have exited the VCL.
  # Typically used to clean up VMODs.

  return (ok);
}
